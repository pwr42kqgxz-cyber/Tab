<!DOCTYPE html>
<html lang="fr" data-theme="classique">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
	<meta http-equiv="Pragma" content="no-cache">
	<meta http-equiv="Expires" content="0">
	<title>Tablature Luth Baroque</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;1,400&family=Tangerine:wght@700&display=swap" rel="stylesheet">

	<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
:root {
	--bg-color: #ffffff;
	--text-color: #000000;
	--line-color: #000000;
	--ui-bg: #ffffff;
	--ui-border: #000000;
	--accent-color: #000000;
	--ui-text: #000000;
}

[data-theme="classique"] {
	--bg-color: #ffffff;
	--text-color: #000000;
	--line-color: #000000;
	--ui-bg: #ffffff;
	--ui-border: #000000;
	--accent-color: #000000;
	--ui-text: #000000;
}

[data-theme="moderne"] {
	--bg-color: #f5f5f5;
	--text-color: #1a1a1a;
	--line-color: #333333;
	--ui-bg: #e8e8e8;
	--ui-border: #666666;
	--accent-color: #4a90e2;
	--ui-text: #1a1a1a;
}

[data-theme="parchemin"] {
	--bg-color: #f4e8d0;
	--text-color: #3d2817;
	--line-color: #5d4730;
	--ui-bg: #ebe0c8;
	--ui-border: #8b7355;
	--accent-color: #8b4513;
	--ui-text: #3d2817;
}

[data-theme="nuit"] {
	--bg-color: #1a1a1a;
	--text-color: #e0e0e0;
	--line-color: #cccccc;
	--ui-bg: #2a2a2a;
	--ui-border: #555555;
	--accent-color: #6a9bd8;
	--ui-text: #e0e0e0;
}

* {
	touch-action: manipulation;
	-webkit-tap-highlight-color: transparent;
	box-sizing: border-box;
}

html, body {
	margin: 0;
	padding: 0;
	height: 100%;
	width: 100%;
	font-family: "EB Garamond", serif;
	overflow: hidden;
	background: var(--bg-color);
	color: var(--text-color);
}

/* ===== TOOLBAR ===== */
#toolbar {
	position: fixed;
	top: 8px;
	left: 50%;
	transform: translateX(-50%);
	width: calc(100% - 16px);
	max-width: 100%;
	display: flex;
	flex-wrap: wrap;
	gap: 6px;
	padding: 6px 8px;
	background: var(--ui-bg);
	border: 1px solid var(--ui-border);
	border-radius: 8px;
	box-shadow: 0 4px 12px rgba(0,0,0,0.15);
	z-index: 20;
}

.drag-handle {
	width: 80px;
	height: 20px;
	background: var(--ui-border);
	border-radius: 10px;
	cursor: grab;
	align-self: center;
	flex-shrink: 0;
	opacity: 0.4;
	position: relative;
}

.drag-handle::after {
	content: "‚ãÆ‚ãÆ‚ãÆ";
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
	color: var(--ui-bg);
	font-size: 16px;
	letter-spacing: 4px;
}

button {
	padding: 6px 10px;
	border: 1px solid var(--ui-border);
	background: var(--ui-bg);
	color: var(--ui-text);
	font-size: 14px;
	border-radius: 4px;
	-webkit-text-fill-color: var(--ui-text);
	appearance: none;
	-webkit-appearance: none;
}

button.active {
	background: var(--accent-color);
	color: white;
	-webkit-text-fill-color: white;
}

button.placing {
	background: var(--accent-color);
	color: white;
	-webkit-text-fill-color: white;
	animation: pulse 1s infinite;
}

button:disabled {
	opacity: 0.5;
	cursor: not-allowed;
}

@keyframes pulse {
	0%, 100% { opacity: 1; }
	50% { opacity: 0.6; }
}

#showUIBtn {
	position: fixed;
	right: 8px;
	top: 8px;
	z-index: 25;
	display: none;
}

/* ===== CANVAS ===== */
#canvas-wrapper {
	position: fixed;
	left: 0;
	right: 0;
	top: 80px;
	bottom: 80px;
	overflow-y: auto;
	overflow-x: hidden;
	-webkit-overflow-scrolling: touch;
}

#canvas {
	position: relative;
	width: 1100px;
	min-height: 1123px;
	margin: 0 auto;
	background: var(--bg-color);
	padding: 10px 20px;
}

/* ===== SYMBOL WRAPPER - CRITIQUE ===== */
.symbol-wrapper {
	position: absolute;
	pointer-events: auto;
	z-index: 10;
	/* ‚úÖ Espace pour hampes descendantes et montantes */
	padding-top: 25px;
	padding-bottom: 25px;
	/* ‚úÖ Force le rendu complet */
	will-change: transform;
}

.symbol {
	font-size: 40px;
	font-family: 'Tangerine', cursive;
	font-weight: 700;
	color: var(--text-color);
	line-height: 1;
	white-space: nowrap;
}

.selected {
	text-shadow: 0 0 5px var(--accent-color);
	color: var(--accent-color);
}

/* ===== DRAW ===== */
.draw {
	position: absolute;
	pointer-events: auto;
}

.draw path {
	fill: none;
	stroke: var(--line-color);
	stroke-width: 2;
	stroke-linecap: round;
	stroke-linejoin: round;
	vector-effect: non-scaling-stroke;
}

/* ===== TITLE ===== */
#print-title {
	text-align: center;
	font-size: 32px;
	margin: 10px 0 20px;
	cursor: text;
	color: var(--text-color);
	font-family: 'EB Garamond', serif !important;
	font-style: normal !important;
	font-weight: 400 !important;
}

/* ===== LINES ===== */
.line {
	position: absolute;
	left: 0;
	height: 1px;
	z-index: 1;
}

.line.black {
	background: var(--line-color);
}

.line.white {
	background: transparent;
}

/* ===== SYSTEM NUMBER ===== */
.system-number {
	position: absolute;
	left: -30px;
	font-size: 14px;
	color: var(--text-color);
	opacity: 0.5;
	pointer-events: none;
}

/* ===== FLASH CONFIRMATION ===== */
@keyframes flash {
	0% { opacity: 0.2; }
	100% { opacity: 1; }
}

.flash {
	animation: flash 0.3s ease-out;
}

/* ===== BAR ===== */
.bar {
	position: absolute;
	width: 1px;
	background: var(--line-color);
	z-index: 2;
}

.system-bar {
	position: absolute;
	width: 1px;
	background: var(--line-color);
}

.system-bar.left { left: 0; }
.system-bar.right { right: 0; }

/* ===== POIGN√âE DE RACCOURCISSEMENT (temporaire) ===== */
.shorten-handle {
	position: absolute;
	width: 24px;
	height: 24px;
	background: var(--accent-color);
	border: 2px solid var(--line-color);
	border-radius: 50%;
	cursor: grab;
	z-index: 15;
	display: flex;
	align-items: center;
	justify-content: center;
	color: white;
	font-size: 12px;
	font-weight: bold;
	box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.shorten-handle::before {
	content: "‚ü∑";
}

.shorten-handle.dragging {
	cursor: grabbing;
	box-shadow: 0 4px 12px rgba(0,0,0,0.5);
}

/* ===== BARRE FINALE √âPAISSE ===== */
.end-bar {
	position: absolute;
	width: 3px;
	background: var(--line-color);
	z-index: 2;
}

/* ===== PALETTE ===== */
#palette {
	position: fixed;
	left: 50%;
	transform: translateX(-50%);
	width: calc(100% - 16px);
	max-width: 100%;
	bottom: 12px;
	padding: 6px 10px;
	display: flex;
	align-items: center;
	gap: 8px;
	background: var(--ui-bg);
	border: 1px solid var(--ui-border);
	border-radius: 8px;
	box-shadow: 0 4px 12px rgba(0,0,0,0.15);
	z-index: 30;
	flex-wrap: nowrap;
	overflow-x: auto;
	overflow-y: hidden;
	white-space: nowrap;
	-webkit-overflow-scrolling: touch;
}

.palette-item {
	flex: 0 0 auto;
	width: 36px;
	height: 36px;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 24px;
	line-height: 1;
	border: 1px solid var(--ui-border);
	background: var(--ui-bg);
	color: var(--ui-text);
	border-radius: 6px;
	padding: 0;
	cursor: pointer;
	font-family: 'Tangerine', cursive;
	font-weight: bold;
}

.palette-item.active {
	background: var(--accent-color);
	color: white;
}

#customChar {
	margin-left: auto;
	width: 60px;
	font-size: 22px;
	text-align: center;
	border: 1px solid var(--ui-border);
	background: var(--ui-bg);
	color: var(--ui-text);
}

/* ===== LOUPE ===== */
.drag-loupe {
	position: fixed;
	width: 120px;
	height: 120px;
	border-radius: 50%;
	overflow: hidden;
	pointer-events: none;
	z-index: 9999;
	background: var(--bg-color);
	border: 2px solid var(--line-color);
	box-shadow: 0 6px 16px rgba(0,0,0,0.3);
	transform: translate(-50%, -160%);
}

.drag-loupe canvas {
	width: 100%;
	height: 100%;
}

.loupe-cross {
	position: absolute;
	left: 50%;
	top: 50%;
	width: 24px;
	height: 24px;
	pointer-events: none;
	transform: translate(-50%, -50%);
}

.loupe-cross::before,
.loupe-cross::after {
	content: "";
	position: absolute;
	background: var(--line-color);
	opacity: 0.7;
}

.loupe-cross::before { left: 0; top: 50%; width: 100%; height: 1px; transform: translateY(-50%); }
.loupe-cross::after { top: 0; left: 50%; width: 1px; height: 100%; transform: translateX(-50%); }

.vertical-guide {
	position: absolute;
	top: 0; bottom: 0; width: 1px;
	background: var(--line-color);
	opacity: 0.15;
	pointer-events: none;
	z-index: 0;
}

/* ===== MODAL ===== */
.modal {
	display: none;
	position: fixed;
	inset: 0;
	background: rgba(0,0,0,0.5);
	z-index: 1000;
	align-items: center;
	justify-content: center;
}

.modal.active { display: flex; }

.modal-content {
	background: var(--ui-bg);
	border: 2px solid var(--ui-border);
	border-radius: 8px;
	padding: 20px;
	max-width: 90%;
	max-height: 80%;
	overflow: auto;
}

.modal-buttons {
	display: flex;
	gap: 10px;
	margin-top: 15px;
	justify-content: flex-end;
}

.page-btn {
	padding: 6px 10px;
	border: 1px solid var(--ui-border);
	background: var(--ui-bg);
	color: var(--ui-text);
	border-radius: 4px;
	font-size: 14px;
	position: relative;
}

.page-btn.active {
	background: var(--accent-color);
	color: white;
	-webkit-text-fill-color: white;
}

.delete-page-btn {
	position: absolute;
	top: -6px;
	right: -6px;
	width: 18px;
	height: 18px;
	border-radius: 50%;
	background: #d32f2f;
	color: white;
	border: none;
	font-size: 12px;
	line-height: 1;
	padding: 0;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
}

.delete-page-btn:hover {
	background: #b71c1c;
}

/* ===== RESPONSIVE ===== */
@media screen and (orientation: landscape) {
	#toolbar { flex-wrap: nowrap; overflow-x: auto; }
	#canvas-wrapper { top: 60px; bottom: 70px; }
}
</style>
</head>
<body>
	<div id="toolbar">
		<div class="drag-handle" id="toolbarHandle"></div>
		<button id="editTitle">Titre</button>
		<button id="toolPlace" class="active">Placer</button>
		<button id="toolSelect">S√©lection</button>
		<button id="undo">Retour</button>
		<button id="deleteBtn">Effacer</button>
		<button id="clearAllBtn">Tout effacer</button>
		<button id="addBar">+ Barre</button>
		<button id="addEndBar">üéµ Raccourcir</button>
		<button id="addSystemBtn">+ Port√©e</button>
		<button id="toggleSnap" class="active">Accroch√©</button>
		<button id="themeBtn">Th√®me</button>
		<button id="saveBtn">üíæ</button>
		<button id="loadBtn">üìÇ</button>
		<button id="toggleUI">üëÅ</button>
		<div id="pageNav"></div>
		<button id="addPageBtn">+ Page</button>
		<button id="exportPDF">PDF</button>
		<button id="toggleVGuides">‚îÇ‚îÇ</button>
	</div>

	<div id="canvas-wrapper">
		<div id="print-title">Titre du Morceau</div>
		<div id="canvas"></div>
	</div>

	<div id="palette">
		<div class="drag-handle" id="paletteHandle"></div>
	</div>

	<button id="showUIBtn">‚¨ÖÔ∏é</button>

	<div id="themeModal" class="modal">
		<div class="modal-content">
			<h3>Choisir un th√®me</h3>
			<button onclick="applyTheme('classique')">Classique</button>
			<button onclick="applyTheme('moderne')">Moderne</button>
			<button onclick="applyTheme('parchemin')">Parchemin</button>
			<button onclick="applyTheme('nuit')">Nuit</button>
			<div class="modal-buttons">
				<button onclick="closeModal('themeModal')">Fermer</button>
			</div>
		</div>
	</div>

	<div id="exportModal" class="modal">
		<div class="modal-content">
			<h3>Options d'export PDF</h3>
			<label>
				<input type="checkbox" id="showSystemNumbers" checked>
				Afficher les num√©ros de syst√®mes
			</label>
			<div class="modal-buttons">
				<button onclick="closeModal('exportModal')">Annuler</button>
				<button onclick="confirmExport()">Exporter</button>
			</div>
		</div>
	</div>

<script>
const VERSION = "tablature-barok-v9";
const MAX_PAGES = 10;

/* ================= DOM ================= */
const toolbar = document.getElementById("toolbar");
const palette = document.getElementById("palette");
const showUIBtn = document.getElementById("showUIBtn");
const toggleUI = document.getElementById("toggleUI");
const canvasWrapper = document.getElementById("canvas-wrapper");
const canvas = document.getElementById("canvas");
const printTitle = document.getElementById("print-title");
const toolPlace = document.getElementById("toolPlace");
const toolSelect = document.getElementById("toolSelect");
const undoBtn = document.getElementById("undo");
const deleteBtn = document.getElementById("deleteBtn");
const clearAllBtn = document.getElementById("clearAllBtn");
const addBar = document.getElementById("addBar");
const addEndBar = document.getElementById("addEndBar");
const toggleSnap = document.getElementById("toggleSnap");
const editTitle = document.getElementById("editTitle");
const toggleVGuides = document.getElementById("toggleVGuides");
const addSystemBtn = document.getElementById("addSystemBtn");
const themeBtn = document.getElementById("themeBtn");
const saveBtn = document.getElementById("saveBtn");
const loadBtn = document.getElementById("loadBtn");
const addPageBtn = document.getElementById("addPageBtn");
const pageNav = document.getElementById("pageNav");

/* ================= STATE ================= */
let pageCount = 1;
let currentPage = 1;
const pages = {};
pages[1] = null;

let systemCount = 1;
const MAX_SYSTEMS = 7;
let showVerticalGuides = false;
let tool = "place";
let snap = true;
let placingBar = false;
let placingEndBar = false;
let deleteMode = false;
let selected = "a";
let selectedElement = null;
let active = null;

let dragLoupe = null;
let loupeCanvas = null;
let loupeCtx = null;
let loupeImage = null;

let currentY = 40;
const LINE_SPACING = 22;
const lines = [];

let drawing = false;
let currentPath = null;
let drawStart = { x: 0, y: 0 };
const DRAW_W = 120;
const DRAW_H = 100;

const undoStack = [];
const MAX_UNDO = 40;

const FIXED_FONT_SIZE = 40;
const SNAP_THRESHOLD = 15;

const systemEnds = {};

/* ================= HAPTIC FEEDBACK ================= */
function haptic() {
	if (navigator.vibrate) navigator.vibrate(10);
}

/* ================= THEME (GLOBAL) ================= */
function applyTheme(themeName) {
	document.documentElement.setAttribute("data-theme", themeName);
	localStorage.setItem("theme", themeName);
	closeModal("themeModal");
	
	for (let i = 1; i <= pageCount; i++) {
		if (pages[i]) {
			const pageData = JSON.parse(pages[i]);
			pageData.theme = themeName;
			pages[i] = JSON.stringify(pageData);
		}
	}
	
	haptic();
}

themeBtn.onclick = () => document.getElementById("themeModal").classList.add("active");

function closeModal(id) { document.getElementById(id).classList.remove("active"); }

document.addEventListener("click", e => {
	if (e.target.classList.contains("modal")) e.target.classList.remove("active");
});

/* ================= PAGE MANAGEMENT ================= */
function renderPageNav() {
	pageNav.innerHTML = "";
	for (let i = 1; i <= pageCount; i++) {
		const wrapper = document.createElement("div");
		wrapper.style.position = "relative";
		wrapper.style.display = "inline-block";
		
		const btn = document.createElement("button");
		btn.className = "page-btn";
		btn.textContent = "Page " + i;
		if (i === currentPage) btn.classList.add("active");
		btn.onclick = () => loadPage(i);
		
		if (pageCount > 1) {
			const delBtn = document.createElement("button");
			delBtn.className = "delete-page-btn";
			delBtn.innerHTML = "√ó";
			delBtn.title = "Supprimer cette page";
			delBtn.onclick = (e) => {
				e.stopPropagation();
				deletePage(i);
			};
			wrapper.appendChild(delBtn);
		}
		
		wrapper.appendChild(btn);
		pageNav.appendChild(wrapper);
	}
}

function deletePage(pageNum) {
	if (pageCount <= 1) {
		alert("Vous ne pouvez pas supprimer la derni√®re page.");
		return;
	}
	
	if (!confirm(`Supprimer la page ${pageNum} ?`)) return;
	
	delete pages[pageNum];
	
	const newPages = {};
	let newIndex = 1;
	for (let i = 1; i <= pageCount; i++) {
		if (i !== pageNum) {
			newPages[newIndex] = pages[i];
			newIndex++;
		}
	}
	
	pageCount--;
	Object.keys(pages).forEach(k => delete pages[k]);
	Object.assign(pages, newPages);
	
	if (currentPage > pageCount) {
		currentPage = pageCount;
	} else if (currentPage >= pageNum) {
		currentPage = Math.max(1, currentPage - 1);
	}
	
	loadPage(currentPage);
	renderPageNav();
	haptic();
}

addPageBtn.onclick = () => {
	if (pageCount >= MAX_PAGES) {
		alert(`Limite de ${MAX_PAGES} pages atteinte.`);
		return;
	}
	
	pageCount++;
	pages[pageCount] = null;
	loadPage(pageCount);
	renderPageNav();
	haptic();
};

function saveCurrentPage() {
	pages[currentPage] = serializeState();
}

function loadPage(n) {
	if (n === currentPage) return;
	saveCurrentPage();
	currentPage = n;
	if (pages[n]) {
		restoreState(pages[n], false);
	} else {
		const title = printTitle.textContent;
		const currentTheme = document.documentElement.getAttribute("data-theme");
		canvas.innerHTML = "";
		lines.length = 0;
		currentY = 40;
		systemCount = 1;
		Object.keys(systemEnds).forEach(k => delete systemEnds[k]);
		printTitle.textContent = title;
		createInitialStructure();
		applyTheme(currentTheme);
		saveCurrentPage();
	}
	renderPageNav();
	haptic();
}

/* ================= SAVE / LOAD ================= */
saveBtn.onclick = () => {
	saveCurrentPage();
	const data = {
		version: VERSION,
		created: new Date().toISOString(),
		title: printTitle.textContent,
		theme: document.documentElement.getAttribute("data-theme"),
		pageCount: pageCount,
		pages: pages
	};
	const json = JSON.stringify(data, null, 2);
	const blob = new Blob([json], { type: "application/json" });
	const url = URL.createObjectURL(blob);
	const a = document.createElement("a");
	a.href = url;
	a.download = `tablature-${Date.now()}.json`;
	a.click();
	URL.revokeObjectURL(url);
	haptic();
};

loadBtn.onclick = () => {
	const input = document.createElement("input");
	input.type = "file";
	input.accept = ".json";
	input.onchange = e => {
		const file = e.target.files[0];
		if (!file) return;
		const reader = new FileReader();
		reader.onload = event => {
			try {
				const data = JSON.parse(event.target.result);
				printTitle.textContent = data.title || "";
				if (data.theme) applyTheme(data.theme);
				pageCount = Math.min(data.pageCount || 1, MAX_PAGES);
				Object.assign(pages, data.pages);
				currentPage = 0;
				loadPage(1);
				renderPageNav();
				haptic();
				alert("Tablature charg√©e !");
			} catch (err) {
				alert("Erreur de chargement : fichier invalide");
			}
		};
		reader.readAsText(file);
	};
	input.click();
};

/* ================= UI VISIBILITY ================= */
toggleUI.onclick = () => {
	toolbar.style.display = "none";
	palette.style.display = "none";
	showUIBtn.style.display = "block";
};
showUIBtn.onclick = () => {
	toolbar.style.display = "";
	palette.style.display = "";
	showUIBtn.style.display = "none";
};

/* ================= UNDO ================= */
function serializeState() {
	return JSON.stringify({
		title: printTitle.textContent,
		theme: document.documentElement.getAttribute("data-theme"),
		systemCount,
		systemEnds,
		elements: [...canvas.children].map(el => {

			if (el.classList.contains("draw")) {
				return {
					class: "draw",
					left: el.style.left,
					top: el.style.top,
					d: el.querySelector("path").getAttribute("d")
				};
			}

			const data = {
				class: el.className,
				text: el.textContent || "",
				left: el.style.left,
				top: el.style.top,
				systemId: el.dataset.systemId || ""
			};

			if (el.classList.contains("symbol-wrapper")) {
				data.centerX = el.dataset.centerX || "";
				data.lineY   = el.dataset.lineY || "";
				data.char    = el.querySelector(".symbol")?.dataset.char || "";
			}

			if (el.classList.contains("line") || el.classList.contains("system-bar") || el.classList.contains("end-bar") || el.classList.contains("bar")) {
				data.height = el.style.height;
				data.width = el.style.width;
				data.right = el.style.right;
			}

			return data;
		})
	});
}

function pushUndo() {
	undoStack.push(serializeState());
	if (undoStack.length > MAX_UNDO) undoStack.shift();
}

undoBtn.onclick = () => {
	if (!undoStack.length) return;
	restoreState(undoStack.pop(), false);
	haptic();
};

/* ================= PERSISTENCE ================= */

function saveState() {
	localStorage.setItem("tablature_state", serializeState());
}

/* ‚úÖ FONCTION DE CALCUL D'OFFSET VERTICAL PAR CARACT√àRE */
function symbolVerticalOffset(char) {
	// Lettres avec hampes descendantes
	if (['g', 'j'].includes(char)) return FIXED_FONT_SIZE * 0.5;
	
	// Lettres avec hampes montantes
	if (['b', 'd', 'f', 'h', 'k', 'l'].includes(char)) return FIXED_FONT_SIZE * 0.65;
	
	// Lettres normales (a, c, e, m, n) - d√©cal√©es un peu plus haut
	return FIXED_FONT_SIZE * 0.60;
}

function restoreState(raw, save = true) {
	const s = typeof raw === "string" ? JSON.parse(raw) : raw;

	canvas.innerHTML = "";
	lines.length = 0;
	currentY = 40;
	systemCount = s.systemCount || 1;
	printTitle.textContent = s.title || "Titre du Morceau";

	Object.keys(systemEnds).forEach(k => delete systemEnds[k]);
	Object.assign(systemEnds, s.systemEnds || {});

	s.elements.forEach(e => {

		if (e.class === "draw") {
			const w = document.createElement("div");
			w.className = "draw";
			w.style.left = e.left;
			w.style.top = e.top;

			const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
			svg.setAttribute("width", DRAW_W);
			svg.setAttribute("height", DRAW_H);

			const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
			p.setAttribute("d", e.d);

			svg.appendChild(p);
			w.appendChild(svg);
			canvas.appendChild(w);
			makeDraggable(w);
			return;
		}

		if (e.class === "symbol-wrapper") {
			const w = document.createElement("div");
			w.className = "symbol-wrapper";

			if (e.systemId) w.dataset.systemId = e.systemId;

			const sEl = document.createElement("div");
			sEl.className = "symbol";
			sEl.textContent = e.text;
			sEl.dataset.char = e.char || e.text || "";

			w.appendChild(sEl);
			canvas.appendChild(w);

			void w.offsetWidth;

			if (e.centerX) {
				const rect = w.getBoundingClientRect();
				const centerOffsetX = rect.width / 2;
				w.style.left = (parseFloat(e.centerX) - centerOffsetX) + "px";
				w.dataset.centerX = e.centerX;
			} else {
				w.style.left = e.left;
			}

			if (e.lineY) {
				const char = sEl.dataset.char;
				const offset = symbolVerticalOffset(char);
				w.style.top = (parseFloat(e.lineY) - offset - 25) + "px";
				w.dataset.lineY = e.lineY;
			} else {
				w.style.top = e.top;
			}

			// ‚úÖ Force le rendu complet apr√®s placement
			requestAnimationFrame(() => {
				w.style.transform = 'translateZ(0)';
			});

			makeDraggable(w);
			return;
		}

		const el = document.createElement("div");
		el.className = e.class;
		el.textContent = e.text || "";
		el.style.left = e.left;
		el.style.top = e.top;

		if (e.height) el.style.height = e.height;
		if (e.width) el.style.width = e.width;
		if (e.right) el.style.right = e.right;
		if (e.systemId) el.dataset.systemId = e.systemId;

		canvas.appendChild(el);

		if (el.classList.contains("line")) {
			lines.push(parseFloat(e.top));
			currentY = parseFloat(e.top) + LINE_SPACING;
		}

		if (el.classList.contains("bar") || el.classList.contains("end-bar")) {
			makeDraggable(el);
		}
	});

	if (showVerticalGuides) renderVerticalGuides();
	if (save) saveState();
}

function restoreFromStorage() {
	const raw = localStorage.getItem("tablature_state");
	const savedTheme = localStorage.getItem("theme");

	if (savedTheme) applyTheme(savedTheme);

	if (raw) restoreState(raw, false);
	else {
		createInitialStructure();
		saveState();
	}
}

/* ================= TITLE ================= */
editTitle.onclick = () => {
	const t = prompt("Titre du morceau :", printTitle.textContent || "");
	if (t === null) return;
	pushUndo();
	printTitle.textContent = t.trim();
	saveState();
	haptic();
};

/* ================= TOOLS ================= */
function setTool(t) {
	tool = t;
	toolPlace.classList.toggle("active", t === "place");
	toolSelect.classList.toggle("active", t === "select");
}

toolPlace.onclick = () => {
	if (tool === "place") { 
		tool = null; 
		toolPlace.classList.remove("active");
	}
	else setTool("place");
	
	deleteMode = false;
	deleteBtn.classList.remove("active");
	
	haptic();
};

toolSelect.onclick = () => {
	setTool("select");
	if (selectedElement) {
		selectedElement.classList.remove("selected");
		selectedElement = null;
	}
	
	deleteMode = false;
	deleteBtn.classList.remove("active");
	
	haptic();
};

deleteBtn.onclick = () => {
	deleteMode = !deleteMode;
	deleteBtn.classList.toggle("active", deleteMode);
	
	if (deleteMode) {
		setTool("select");
	}
	
	haptic();
};

toggleSnap.onclick = () => {
	snap = !snap;
	toggleSnap.classList.toggle("active", snap);
	haptic();
};

toggleVGuides.onclick = () => {
	showVerticalGuides = !showVerticalGuides;
	toggleVGuides.classList.toggle("active", showVerticalGuides);
	renderVerticalGuides();
	haptic();
};

/* ================= STRUCTURE ================= */
function addLine(type, systemId = null) {
	const l = document.createElement("div");
	l.className = "line " + type;
	l.style.top = currentY + "px";
	if (systemId) {
		l.dataset.systemId = systemId;
		if (systemEnds[systemId]) {
			l.style.right = systemEnds[systemId] + "px";
		} else {
			l.style.right = "0";
		}
	} else {
		l.style.right = "0";
	}
	canvas.appendChild(l);
	lines.push(currentY);
	currentY += LINE_SPACING;
	if (currentY + 100 > canvas.offsetHeight) canvas.style.minHeight = (currentY + 200) + "px";
}

function addSystemSideBars(startY, systemNum) {
	const systemId = `system-${systemNum}`;
	
	const leftBar = document.createElement("div");
	leftBar.className = "bar system-bar left";
	leftBar.style.top = startY + "px";
	leftBar.style.height = (5 * LINE_SPACING) + "px";
	leftBar.dataset.systemId = systemId;

	const rightBar = document.createElement("div");
	rightBar.className = "bar system-bar right";
	rightBar.style.top = startY + "px";
	rightBar.style.height = (5 * LINE_SPACING) + "px";
	rightBar.dataset.systemId = systemId;

	const numLabel = document.createElement("div");
	numLabel.className = "system-number";
	numLabel.textContent = systemNum;
	numLabel.style.top = startY + "px";

	canvas.appendChild(leftBar);
	canvas.appendChild(rightBar);
	canvas.appendChild(numLabel);
}

function createInitialStructure() {
	addLine("white");
	addLine("white");
	const systemTop = currentY;
	const systemId = `system-1`;
	for (let i = 0; i < 6; i++) addLine("black", systemId);
	addSystemSideBars(systemTop, 1);
	systemCount = 1;
}

addSystemBtn.onclick = () => {
	if (systemCount >= MAX_SYSTEMS) { alert(`Max ${MAX_SYSTEMS} port√©es`); return; }
	pushUndo();
	addLine("white");
	addLine("white");
	const systemTop = currentY;
	systemCount++;
	const systemId = `system-${systemCount}`;
	for (let i = 0; i < 6; i++) addLine("black", systemId);
	addSystemSideBars(systemTop, systemCount);
	if (systemCount === MAX_SYSTEMS) addLine("white");
	saveState();
	haptic();
};

/* ================= SNAP ================= */
function nearestLine(y) {
	return lines.reduce((a, b) => Math.abs(b - y) < Math.abs(a - y) ? b : a);
}
function snapY(y) { return (snap && lines.length) ? nearestLine(y) : y; }

function snapToNearbySymbols(x, y) {
	if (!snap) return x;

	const wrappers = document.querySelectorAll(".symbol-wrapper");
	let nearestX = null;
	let minDist = SNAP_THRESHOLD;

	wrappers.forEach(w => {
		const wy = parseFloat(w.dataset.lineY);
		if (isNaN(wy)) return;

		if (Math.abs(wy - y) < LINE_SPACING * 3) {
			const centerX = parseFloat(w.dataset.centerX);
			if (isNaN(centerX)) return;

			const dist = Math.abs(centerX - x);

			if (dist < minDist) {
				minDist = dist;
				nearestX = centerX;
			}
		}
	});

	return nearestX !== null ? nearestX : x;
}

function firstLineOfSystem(y) {
	const lineY = nearestLine(y);
	let idx = lines.indexOf(lineY);
	let count = 0;
	while (idx > 0 && count < 5) {
		const prevY = lines[idx - 1];
		if (!document.querySelector(`.line.black[style*="top: ${prevY}px"]`)) break;
		idx--;
		count++;
	}
	return lines[idx];
}

function getSystemIdAtY(y) {
	const lineY = nearestLine(y);
	const lineEl = document.querySelector(`.line.black[style*="top: ${lineY}px"]`);
	return lineEl ? lineEl.dataset.systemId : null;
}

function renderVerticalGuides() {
	document.querySelectorAll(".vertical-guide").forEach(g => g.remove());
	if (!showVerticalGuides) return;
	const step = 30;
	const width = canvas.offsetWidth;
	for (let x = step; x < width; x += step) {
		const g = document.createElement("div");
		g.className = "vertical-guide";
		g.style.left = x + "px";
		canvas.appendChild(g);
	}
}

/* ================= RACCOURCISSEMENT DE SYST√àME ================= */
function updateSystemEnd(systemId, rightOffset) {
	systemEnds[systemId] = rightOffset;
	
	const systemLines = document.querySelectorAll(`.line[data-system-id="${systemId}"]`);
	systemLines.forEach(line => {
		line.style.right = rightOffset + "px";
	});
	
	const rightBar = document.querySelector(`.system-bar.right[data-system-id="${systemId}"]`);
	if (rightBar) {
		rightBar.style.right = rightOffset + "px";
	}
	
	let endBar = document.querySelector(`.end-bar[data-system-id="${systemId}"]`);
	if (!endBar) {
		const topLine = parseFloat(systemLines[0].style.top);
		endBar = document.createElement("div");
		endBar.className = "end-bar";
		endBar.dataset.systemId = systemId;
		endBar.style.top = topLine + "px";
		endBar.style.height = (5 * LINE_SPACING) + "px";
		canvas.appendChild(endBar);
	}
	endBar.style.right = rightOffset + "px";
}

/* ================= INTERACTION ================= */
function getCanvasCoords(touch) {
	const canvasRect = canvas.getBoundingClientRect();
	return {
		x: touch.clientX - canvasRect.left,
		y: touch.clientY - canvasRect.top
	};
}

canvas.addEventListener("touchstart", e => {
	if (deleteMode && e.target.closest(".symbol-wrapper, .bar:not(.system-bar), .end-bar, .draw")) {
		e.preventDefault();
		pushUndo();
		e.target.closest(".symbol-wrapper, .bar:not(.system-bar), .end-bar, .draw").remove();
		saveState();
		haptic();
		return;
	}

	const { x, y } = getCanvasCoords(e.touches[0]);
	
	// ‚úÖ Ne pas pushUndo si on est en mode placement bar/endbar (pour √©viter de sauvegarder avant l'action)
	if (!placingBar && !placingEndBar) {
		pushUndo();
	}

	if (selected === "__draw__") {
		drawing = true;
		drawStart = { x, y };

		const w = document.createElement("div");
		w.className = "draw";
		w.style.left = (x - DRAW_W / 2) + "px";
		w.style.top  = (y - DRAW_H / 2) + "px";

		const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
		svg.setAttribute("width", DRAW_W);
		svg.setAttribute("height", DRAW_H);

		const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
		p.setAttribute("d", `M ${DRAW_W / 2} ${DRAW_H / 2}`);

		svg.appendChild(p);
		w.appendChild(svg);
		canvas.appendChild(w);

		currentPath = p;
		selectedElement = w;
		return;
	}

	if (placingBar) {
		pushUndo(); // ‚úÖ Push undo AVANT de placer la barre
		placingBar = false;
		addBar.classList.remove("placing");

		const topLine = firstLineOfSystem(y);
		const b = document.createElement("div");
		b.className = "bar";
		b.style.left = x + "px";
		b.style.top = topLine + "px";
		b.style.height = (5 * LINE_SPACING) + "px";

		canvas.appendChild(b);
		makeDraggable(b);
		saveState();
		haptic();
		return;
	}

	if (placingEndBar) {
		pushUndo(); // ‚úÖ Push undo AVANT de raccourcir
		placingEndBar = false;
		addEndBar.classList.remove("placing");

		const systemId = getSystemIdAtY(y);
		if (!systemId) {
			alert("Veuillez cliquer sur un syst√®me (port√©e)");
			return;
		}

		const rightOffset = canvas.offsetWidth - x;
		updateSystemEnd(systemId, rightOffset);
		saveState();
		haptic();
		return;
	}

	if (tool === "place" && selected !== "__draw__") {
		const snappedY = snapY(y);
		const snappedX = snapToNearbySymbols(x, snappedY);

		const w = document.createElement("div");
		w.className = "symbol-wrapper";

		const s = document.createElement("div");
		s.className = "symbol";
		s.textContent = selected;
		s.dataset.char = selected;

		w.appendChild(s);
		canvas.appendChild(w);

		void w.offsetWidth;

		const rect = w.getBoundingClientRect();
		const centerOffsetX = rect.width / 2;
		w.style.left = (snappedX - centerOffsetX) + "px";
		w.dataset.centerX = snappedX;

		const offset = symbolVerticalOffset(selected);
		w.style.top = (snappedY - offset - 25) + "px";
		w.dataset.lineY = snappedY;

		// ‚úÖ Force le rendu complet apr√®s placement
		requestAnimationFrame(() => {
			w.style.transform = 'translateZ(0)';
		});

		makeDraggable(w);
		saveState();
		haptic();
	}
}, { passive: false });

canvas.addEventListener("touchmove", e => {
	if (!drawing) return;
	e.preventDefault();

	const { x, y } = getCanvasCoords(e.touches[0]);
	currentPath.setAttribute(
		"d",
		currentPath.getAttribute("d") +
		` L ${x - drawStart.x + DRAW_W / 2} ${y - drawStart.y + DRAW_H / 2}`
	);
}, { passive: false });

canvas.addEventListener("touchend", () => {
	if (!drawing) return;
	drawing = false;
	currentPath = null;

	selected = "a";
	tool = null;
	toolPlace.classList.remove("active");
	document.querySelectorAll(".palette-item").forEach(i => i.classList.remove("active"));
	saveState();
});

/* ================= DRAG / SELECTION ================= */
function makeDraggable(el) {
	el.addEventListener("touchstart", async e => {
		if (tool !== "select") return;
		e.preventDefault();
		pushUndo();

		if (selectedElement && selectedElement !== el) {
			selectedElement.classList.remove("selected");
		}

		selectedElement = el;
		el.classList.add("selected");
		active = el;
		haptic();

		if (!dragLoupe) {
			dragLoupe = document.createElement("div");
			dragLoupe.className = "drag-loupe";

			loupeCanvas = document.createElement("canvas");
			loupeCanvas.width = 120;
			loupeCanvas.height = 120;
			loupeCtx = loupeCanvas.getContext("2d");

			dragLoupe.appendChild(loupeCanvas);
			document.body.appendChild(dragLoupe);

			const cross = document.createElement("div");
			cross.className = "loupe-cross";
			dragLoupe.appendChild(cross);

			const snapImg = await html2canvas(canvas, {
				backgroundColor: getComputedStyle(canvas).backgroundColor,
				scale: 2,
				logging: false
			});

			loupeImage = snapImg;
		}
	}, { passive: false });

	el.addEventListener("touchmove", e => {
		if (!active || !loupeImage) return;
		e.preventDefault();

		const t = e.touches[0];
		const { x, y } = getCanvasCoords(t);
		const snappedY = snapY(y);
		const snappedX = snapToNearbySymbols(x, snappedY);

		if (active.classList.contains("symbol-wrapper")) {
			const char = active.querySelector(".symbol")?.dataset.char || "";
			const offset = symbolVerticalOffset(char);

			active.style.top = (snappedY - offset - 25) + "px";
			active.dataset.lineY = snappedY;

			const rect = active.getBoundingClientRect();
			const centerOffsetX = rect.width / 2;
			active.style.left = (snappedX - centerOffsetX) + "px";
			active.dataset.centerX = snappedX;

			// ‚úÖ Force rendu pendant drag
			active.style.transform = 'translateZ(0)';
		} else {
			active.style.left = snappedX + "px";
			active.style.top = snappedY + "px";
		}

		dragLoupe.style.left = t.clientX + "px";
		dragLoupe.style.top  = t.clientY + "px";

		loupeCtx.clearRect(0, 0, 120, 120);
		loupeCtx.drawImage(
			loupeImage,
			(x * 2) - 50,
			(y * 2) - 50,
			100,
			100,
			0,
			0,
			120,
			120
		);
	}, { passive: false });

	el.addEventListener("touchend", () => {
		if (dragLoupe) {
			dragLoupe.remove();
			dragLoupe = null;
		}
		active = null;
		saveState();
	});
}

/* ================= DELETE / CLEAR ================= */
clearAllBtn.onclick = () => {
	if (!confirm("Effacer toute la tablature ?")) return;
	pushUndo();
	canvas.innerHTML = "";
	lines.length = 0;
	currentY = 40;
	systemCount = 1;
	Object.keys(systemEnds).forEach(key => delete systemEnds[key]);
	createInitialStructure();
	saveState();
	haptic();
};

addBar.onclick = () => {
	placingBar = true;
	placingEndBar = false;
	addBar.classList.add("placing");
	addEndBar.classList.remove("placing");
	setTool("place");
	
	deleteMode = false;
	deleteBtn.classList.remove("active");
	
	haptic();
};

addEndBar.onclick = () => {
	placingEndBar = true;
	placingBar = false;
	addEndBar.classList.add("placing");
	addBar.classList.remove("placing");
	setTool("place");
	
	deleteMode = false;
	deleteBtn.classList.remove("active");
	
	haptic();
};

/* ================= PALETTE ================= */
[
	"a","b","c","d","e","f","g","h","j","k",
	"l","m","n",
	"/a","//a","///a","4","5","6",
	",",".","‚å¢","‚å£","|","‚úé"
].forEach(s => {
	const p = document.createElement("div");
	p.className = "palette-item";
	p.textContent = s;

	p.onclick = () => {
		document.querySelectorAll(".palette-item").forEach(item => item.classList.remove("active"));
		p.classList.add("active");
		selected = (s === "‚úé") ? "__draw__" : s;
		setTool("place");
		
		deleteMode = false;
		deleteBtn.classList.remove("active");
		
		haptic();
	};
	palette.appendChild(p);
});

const customInput = document.createElement("input");
customInput.id = "customChar";
customInput.placeholder = "‚ú±";
customInput.maxLength = 3;
customInput.oninput = () => {
	if (customInput.value.trim() !== "") {
		selected = customInput.value.trim();
		setTool("place");
		
		deleteMode = false;
		deleteBtn.classList.remove("active");
	}
};
palette.appendChild(customInput);

/* ================= EXPORT PDF ================= */
document.getElementById("exportPDF").onclick = () => document.getElementById("exportModal").classList.add("active");

async function confirmExport() {
	const showNumbers = document.getElementById("showSystemNumbers").checked;
	if (!showNumbers) document.querySelectorAll(".system-number").forEach(n => n.style.display = "none");
	
	closeModal("exportModal");
	saveCurrentPage();
	const originalPage = currentPage;
	const ui = [toolbar, palette];
	ui.forEach(el => el.style.display = "none");
	await new Promise(r => requestAnimationFrame(r));

	const pdf = new jspdf.jsPDF("p", "mm", "a4");
	const pageWidth = 210;
	const y = 15;

	const capture = async (pageNum, addPage) => {
		if (!pages[pageNum]) return;
		loadPage(pageNum);
		await new Promise(r => setTimeout(r, 150));
		const exportWrapper = document.createElement("div");
		exportWrapper.style.background = getComputedStyle(document.body).backgroundColor;
		exportWrapper.style.padding = "20px 24px";
		const titleClone = printTitle.cloneNode(true);
		titleClone.style.marginBottom = "16px";
		exportWrapper.appendChild(titleClone);
		const canvasClone = canvas.cloneNode(true);
		exportWrapper.appendChild(canvasClone);
		document.body.appendChild(exportWrapper);

		const canvasImg = await html2canvas(exportWrapper, {
			scale: 4,
			backgroundColor: getComputedStyle(document.body).backgroundColor,
			useCORS: true,
			logging: false,
			removeContainer: true
		});
		exportWrapper.remove();
		const imgWidth = pageWidth;
		const imgHeight = canvasImg.height * imgWidth / canvasImg.width;
		if (addPage) pdf.addPage();
		pdf.addImage(canvasImg.toDataURL("image/png"), "PNG", 0, y, imgWidth, imgHeight);
	};

	for (let i = 1; i <= pageCount; i++) await capture(i, i > 1);
	loadPage(originalPage);
	ui.forEach(el => el.style.display = "");
	if (!showNumbers) document.querySelectorAll(".system-number").forEach(n => n.style.display = "");
	
	pdf.save("tablature-barok.pdf");
	haptic();
}

/* ================= UI DRAG VERTICAL ================= */
function makeUIDraggableVertical(el, handleEl, storageKey) {
	let startY = 0, startTop = 0, dragging = false;
	handleEl.addEventListener("touchstart", e => {
		startY = e.touches[0].clientY;
		startTop = el.getBoundingClientRect().top;
		dragging = true; el.style.transition = "none"; e.stopPropagation();
	}, { passive: false });
	document.addEventListener("touchmove", e => {
		if (!dragging) return;
		e.preventDefault();
		let newTop = startTop + (e.touches[0].clientY - startY);
		newTop = Math.max(8, Math.min(window.innerHeight - el.offsetHeight - 8, newTop));
		el.style.top = newTop + "px"; el.style.bottom = "auto";
	}, { passive: false });
	document.addEventListener("touchend", () => {
		if (dragging) { localStorage.setItem(storageKey, el.style.top); el.style.transition = ""; dragging = false; }
	});
}
function restoreUIVerticalPosition(el, storageKey, defaultTop) {
	const saved = localStorage.getItem(storageKey);
	if (saved) { el.style.top = saved; el.style.bottom = "auto"; }
	else if (defaultTop) { el.style.top = defaultTop; el.style.bottom = "auto"; }
}

/* ================= INIT ================= */
document.addEventListener("visibilitychange", () => {
	if (document.visibilityState === "hidden") {
		saveState();
	}
});

window.addEventListener("pagehide", () => {
	saveState();
});

restoreFromStorage();
renderPageNav();
initUndoBaseline();

restoreUIVerticalPosition(toolbar, "toolbarY", "8px");
restoreUIVerticalPosition(palette, "paletteY", null);

makeUIDraggableVertical(
	toolbar,
	document.getElementById("toolbarHandle"),
	"toolbarY"
);

makeUIDraggableVertical(
	palette,
	document.getElementById("paletteHandle"),
	"paletteY"
);

function initUndoBaseline() {
	undoStack.length = 0;
	undoStack.push(serializeState());
}
</script>
</body>
</html>
