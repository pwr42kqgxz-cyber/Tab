<!DOCTYPE html>
<html lang="fr" data-theme="classique">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
	<meta http-equiv="Pragma" content="no-cache">
	<meta http-equiv="Expires" content="0">
	<title>Tablature Luth Baroque</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;1,400&family=IM+Fell+English:ital@1&family=Tangerine:wght@700&display=swap" rel="stylesheet">

	<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
:root {
	--bg-color: #ffffff;
	--text-color: #000000;
	--line-color: #000000;
	--ui-bg: #ffffff;
	--ui-border: #000000;
	--accent-color: #000000;
	--ui-text: #000000;
}

[data-theme="classique"] {
	--bg-color: #ffffff;
	--text-color: #000000;
	--line-color: #000000;
	--ui-bg: #ffffff;
	--ui-border: #000000;
	--accent-color: #000000;
	--ui-text: #000000;
}

[data-theme="moderne"] {
	--bg-color: #f5f5f5;
	--text-color: #1a1a1a;
	--line-color: #333333;
	--ui-bg: #e8e8e8;
	--ui-border: #666666;
	--accent-color: #4a90e2;
	--ui-text: #1a1a1a;
}

[data-theme="parchemin"] {
	--bg-color: #f4e8d0;
	--text-color: #3d2817;
	--line-color: #5d4730;
	--ui-bg: #ebe0c8;
	--ui-border: #8b7355;
	--accent-color: #8b4513;
	--ui-text: #3d2817;
}

[data-theme="nuit"] {
	--bg-color: #1a1a1a;
	--text-color: #e0e0e0;
	--line-color: #cccccc;
	--ui-bg: #2a2a2a;
	--ui-border: #555555;
	--accent-color: #6a9bd8;
	--ui-text: #e0e0e0;
}

* {
	touch-action: manipulation;
	-webkit-tap-highlight-color: transparent;
	box-sizing: border-box;
}

html, body {
	margin: 0;
	padding: 0;
	height: 100%;
	width: 100%;
	font-family: "EB Garamond", serif; /* D√©faut syst√®me */
	overflow: hidden;
	background: var(--bg-color);
	color: var(--text-color);
}

/* ===== TOOLBAR ===== */
#toolbar {
	position: fixed;
	top: 8px;
	left: 50%;
	transform: translateX(-50%);
	width: calc(100% - 16px);
	max-width: 100%;
	display: flex;
	flex-wrap: wrap;
	gap: 6px;
	padding: 6px 8px;
	background: var(--ui-bg);
	border: 1px solid var(--ui-border);
	border-radius: 8px;
	box-shadow: 0 4px 12px rgba(0,0,0,0.15);
	z-index: 20;
}

.drag-handle {
	width: 80px;
	height: 20px;
	background: var(--ui-border);
	border-radius: 10px;
	cursor: grab;
	align-self: center;
	flex-shrink: 0;
	opacity: 0.4;
	position: relative;
}

.drag-handle::after {
	content: "‚ãÆ‚ãÆ‚ãÆ";
	position: absolute;
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%);
	color: var(--ui-bg);
	font-size: 16px;
	letter-spacing: 4px;
}

button {
	padding: 6px 10px;
	border: 1px solid var(--ui-border);
	background: var(--ui-bg);
	color: var(--ui-text);
	font-size: 14px;
	border-radius: 4px;
	-webkit-text-fill-color: var(--ui-text);
	appearance: none;
	-webkit-appearance: none;
}

button.active {
	background: var(--accent-color);
	color: white;
	-webkit-text-fill-color: white;
}

button.placing {
	background: var(--accent-color);
	color: white;
	-webkit-text-fill-color: white;
	animation: pulse 1s infinite;
}

@keyframes pulse {
	0%, 100% { opacity: 1; }
	50% { opacity: 0.6; }
}

#showUIBtn {
	position: fixed;
	right: 8px;
	top: 8px;
	z-index: 25;
	display: none;
}

/* ===== CANVAS ===== */
#canvas-wrapper {
	position: absolute;
	top: 80px;
	bottom: 80px;
	left: 0;
	right: 0;
	overflow: auto;
	-webkit-overflow-scrolling: touch;
	background: var(--bg-color);
}

#canvas {
	position: relative;
	width: 1100px;
	min-height: 1123px;
	margin: 0 auto;
	background: var(--bg-color);
	padding: 10px 20px;
}

/* ===== DRAW ===== */
.draw {
	position: absolute;
	pointer-events: auto;
}

.draw path {
	fill: none;
	stroke: var(--line-color);
	stroke-width: 2;
	stroke-linecap: round;
	stroke-linejoin: round;
	vector-effect: non-scaling-stroke;
}

/* ===== TITLE ===== */
#print-title {
	text-align: center;
	font-size: 32px;
	margin: 10px 0 20px;
	cursor: text;
	color: var(--text-color);
	/* FORCE LE TITRE EN EB GARAMOND NORMAL */
	font-family: 'EB Garamond', serif !important;
	font-style: normal !important;
	font-weight: 400;
}

/* ===== LINES ===== */
.line {
	position: absolute;
	left: 0;
	right: 0;
	height: 1px;
	z-index: 1; /* Ligne en dessous du texte */
}

.line.black {
	background: var(--line-color);
}

.line.white {
	background: transparent;
}

/* ===== SYSTEM NUMBER ===== */
.system-number {
	position: absolute;
	left: -30px;
	font-size: 14px;
	color: var(--text-color);
	opacity: 0.5;
	pointer-events: none;
}

/* ===== SYMBOLS (CORRECTION CLIPPING) ===== */
.symbol {
	position: absolute;
	font-size: 26px;
	white-space: nowrap;
	
	/* CORRECTION MAJEURE POUR LES GRANDES POLICES (Tangerine) */
	line-height: normal; /* Laisse la hauteur naturelle de la police */
	height: auto;        /* Pas de hauteur fixe qui coupe */
	overflow: visible;   /* Autorise le d√©bordement visuel */
	padding: 10px 0;     /* Marge de s√©curit√© pour les grandes boucles */
	margin-top: -10px;   /* Compenstation du padding pour garder le centrage */
	
	transform: translateX(-50%);
	color: var(--text-color);
	text-rendering: geometricPrecision;
	-webkit-font-smoothing: antialiased;
	
	z-index: 10; /* Le texte passe AU-DESSUS des lignes */
}

.selected {
	text-shadow: 0 0 5px var(--accent-color); /* Mieux que box-shadow pour les polices complexes */
	color: var(--accent-color);
}

/* ===== FLASH CONFIRMATION ===== */
@keyframes flash {
	0% { opacity: 0.2; }
	100% { opacity: 1; }
}

.flash {
	animation: flash 0.3s ease-out;
}

/* ===== BAR ===== */
.bar {
	position: absolute;
	width: 1px;
	background: var(--line-color);
	z-index: 2;
}

.system-bar {
	position: absolute;
	width: 1px;
	background: var(--line-color);
}

.system-bar.left { left: 0; }
.system-bar.right { right: 0; }

/* ===== PALETTE ===== */
#palette {
	position: fixed;
	left: 50%;
	transform: translateX(-50%);
	width: calc(100% - 16px);
	max-width: 100%;
	bottom: 12px;
	padding: 6px 10px;
	display: flex;
	align-items: center;
	gap: 8px;
	background: var(--ui-bg);
	border: 1px solid var(--ui-border);
	border-radius: 8px;
	box-shadow: 0 4px 12px rgba(0,0,0,0.15);
	z-index: 30;
	flex-wrap: nowrap;
	overflow-x: auto;
	overflow-y: hidden;
	white-space: nowrap;
	-webkit-overflow-scrolling: touch;
}

.palette-item {
	flex: 0 0 auto;
	width: 36px;
	height: 36px;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 24px;
	line-height: 1;
	border: 1px solid var(--ui-border);
	background: var(--ui-bg);
	color: var(--ui-text);
	border-radius: 6px;
	padding: 0;
	cursor: pointer;
	font-family: 'Tangerine', cursive; /* Police par d√©faut de la palette */
	font-weight: bold;
}

.palette-item.active {
	background: var(--accent-color);
	color: white;
}

#customChar {
	margin-left: auto;
	width: 60px;
	font-size: 22px;
	text-align: center;
	border: 1px solid var(--ui-border);
	background: var(--ui-bg);
	color: var(--ui-text);
}

/* ===== FONT SIZE CONTROLS ===== */
.font-size-controls {
	display: flex;
	gap: 4px;
	align-items: center;
	margin-left: 6px;
}

.font-size-btn {
	width: 28px;
	height: 28px;
	padding: 0;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 16px;
	font-weight: bold;
}

#fontSizeDisplay {
	width: 40px;
	text-align: center;
	font-size: 14px;
	border: 1px solid var(--ui-border);
	background: var(--ui-bg);
	color: var(--ui-text);
	padding: 4px;
	border-radius: 4px;
}

/* ===== LOUPE ===== */
.drag-loupe {
	position: fixed;
	width: 120px;
	height: 120px;
	border-radius: 50%;
	overflow: hidden;
	pointer-events: none;
	z-index: 9999;
	background: var(--bg-color);
	border: 2px solid var(--line-color);
	box-shadow: 0 6px 16px rgba(0,0,0,0.3);
	transform: translate(-50%, -160%);
}

.drag-loupe canvas {
	width: 100%;
	height: 100%;
}

.loupe-cross {
	position: absolute;
	left: 50%;
	top: 50%;
	width: 24px;
	height: 24px;
	pointer-events: none;
	transform: translate(-50%, -50%);
}

.loupe-cross::before,
.loupe-cross::after {
	content: "";
	position: absolute;
	background: var(--line-color);
	opacity: 0.7;
}

.loupe-cross::before { left: 0; top: 50%; width: 100%; height: 1px; transform: translateY(-50%); }
.loupe-cross::after { top: 0; left: 50%; width: 1px; height: 100%; transform: translateX(-50%); }

.vertical-guide {
	position: absolute;
	top: 0; bottom: 0; width: 1px;
	background: var(--line-color);
	opacity: 0.15;
	pointer-events: none;
	z-index: 0;
}

/* ===== MODAL ===== */
.modal {
	display: none;
	position: fixed;
	inset: 0;
	background: rgba(0,0,0,0.5);
	z-index: 1000;
	align-items: center;
	justify-content: center;
}

.modal.active { display: flex; }

.modal-content {
	background: var(--ui-bg);
	border: 2px solid var(--ui-border);
	border-radius: 8px;
	padding: 20px;
	max-width: 90%;
	max-height: 80%;
	overflow: auto;
}

.modal-buttons {
	display: flex;
	gap: 10px;
	margin-top: 15px;
	justify-content: flex-end;
}

.page-btn {
	padding: 6px 10px;
	border: 1px solid var(--ui-border);
	background: var(--ui-bg);
	color: var(--ui-text);
	border-radius: 4px;
	font-size: 14px;
}

.page-btn.active {
	background: var(--accent-color);
	color: white;
	-webkit-text-fill-color: white;
}

/* ===== RESPONSIVE ===== */
@media screen and (orientation: landscape) {
	#toolbar { flex-wrap: nowrap; overflow-x: auto; }
	#canvas-wrapper { top: 60px; bottom: 70px; }
}
</style>
</head>
<body>
	<div id="toolbar">
		<div class="drag-handle" id="toolbarHandle"></div>
		<button id="editTitle">Titre</button>
		<button id="toolPlace" class="active">Placer</button>
		<button id="toolSelect">S√©lection</button>
		<button id="undo">Retour</button>
		<button id="deleteBtn">Effacer</button>
		<button id="clearAllBtn">Tout effacer</button>
		<button id="addBar">+ Barre</button>
		<button id="addSystemBtn">+ Port√©e</button>
		<button id="toggleSnap" class="active">Accroch√©</button>
		<button id="themeBtn">Th√®me</button>
		<button id="saveBtn">üíæ</button>
		<button id="loadBtn">üìÇ</button>
		<button id="toggleUI">üëÅ</button>
		<div id="pageNav"></div>
		<button id="addPageBtn">+ Page</button>
		<button id="exportPDF">PDF</button>
		<button id="toggleVGuides">‚îÇ‚îÇ</button>
	</div>

	<div id="canvas-wrapper">
		<div id="print-title">Titre du Morceau</div>
		<div id="canvas"></div>
	</div>

	<div id="palette">
		<div class="drag-handle" id="paletteHandle"></div>
	</div>

	<button id="showUIBtn">‚¨ÖÔ∏é</button>

	<div id="themeModal" class="modal">
		<div class="modal-content">
			<h3>Choisir un th√®me</h3>
			<button onclick="applyTheme('classique')">Classique</button>
			<button onclick="applyTheme('moderne')">Moderne</button>
			<button onclick="applyTheme('parchemin')">Parchemin</button>
			<button onclick="applyTheme('nuit')">Nuit</button>
			<div class="modal-buttons">
				<button onclick="closeModal('themeModal')">Fermer</button>
			</div>
		</div>
	</div>

	<div id="exportModal" class="modal">
		<div class="modal-content">
			<h3>Options d'export PDF</h3>
			<label>
				<input type="checkbox" id="showSystemNumbers" checked>
				Afficher les num√©ros de syst√®mes
			</label>
			<div class="modal-buttons">
				<button onclick="closeModal('exportModal')">Annuler</button>
				<button onclick="confirmExport()">Exporter</button>
			</div>
		</div>
	</div>

<script>
const VERSION = "tablature-barok-v2";

/* ================= DOM ================= */
const toolbar = document.getElementById("toolbar");
const palette = document.getElementById("palette");
const showUIBtn = document.getElementById("showUIBtn");
const toggleUI = document.getElementById("toggleUI");
const canvasWrapper = document.getElementById("canvas-wrapper");
const canvas = document.getElementById("canvas");
const printTitle = document.getElementById("print-title");
const toolPlace = document.getElementById("toolPlace");
const toolSelect = document.getElementById("toolSelect");
const undoBtn = document.getElementById("undo");
const deleteBtn = document.getElementById("deleteBtn");
const clearAllBtn = document.getElementById("clearAllBtn");
const addBar = document.getElementById("addBar");
const toggleSnap = document.getElementById("toggleSnap");
const editTitle = document.getElementById("editTitle");
const toggleVGuides = document.getElementById("toggleVGuides");
const addSystemBtn = document.getElementById("addSystemBtn");
const themeBtn = document.getElementById("themeBtn");
const saveBtn = document.getElementById("saveBtn");
const loadBtn = document.getElementById("loadBtn");
const addPageBtn = document.getElementById("addPageBtn");
const pageNav = document.getElementById("pageNav");

/* ================= STATE ================= */
let pageCount = 1;
let currentPage = 1;
const pages = {};
pages[1] = null;

let systemCount = 1;
const MAX_SYSTEMS = 7;
let showVerticalGuides = false;
let tool = "place";
let snap = true;
let placingBar = false;
let selected = "a";
let selectedElement = null;
let active = null;

let dragLoupe = null;
let loupeCanvas = null;
let loupeCtx = null;
let loupeImage = null;

let currentY = 40;
const LINE_SPACING = 22;
const lines = [];

let drawing = false;
let currentPath = null;
let drawStart = { x: 0, y: 0 };
const DRAW_W = 120;
const DRAW_H = 100;

const undoStack = [];
const MAX_UNDO = 40;

let currentFontSize = 26;
const SNAP_THRESHOLD = 15;

/* ================= HAPTIC FEEDBACK ================= */
function haptic() {
	if (navigator.vibrate) navigator.vibrate(10);
}

/* ================= THEME ================= */
function applyTheme(themeName) {
	document.documentElement.setAttribute("data-theme", themeName);
	localStorage.setItem("theme", themeName);
	closeModal("themeModal");
	haptic();
}

themeBtn.onclick = () => document.getElementById("themeModal").classList.add("active");

function closeModal(id) { document.getElementById(id).classList.remove("active"); }

document.addEventListener("click", e => {
	if (e.target.classList.contains("modal")) e.target.classList.remove("active");
});

/* ================= PAGE MANAGEMENT ================= */
function renderPageNav() {
	pageNav.innerHTML = "";
	for (let i = 1; i <= pageCount; i++) {
		const btn = document.createElement("button");
		btn.className = "page-btn";
		btn.textContent = "Page " + i;
		if (i === currentPage) btn.classList.add("active");
		btn.onclick = () => loadPage(i);
		pageNav.appendChild(btn);
	}
}

addPageBtn.onclick = () => {
	pageCount++;
	pages[pageCount] = null;
	loadPage(pageCount);
	renderPageNav();
	haptic();
};

function saveCurrentPage() {
	pages[currentPage] = serializeState();
}

function loadPage(n) {
	if (n === currentPage) return;
	saveCurrentPage();
	currentPage = n;
	if (pages[n]) {
		restoreState(pages[n], false);
	} else {
		const title = printTitle.textContent;
		canvas.innerHTML = "";
		lines.length = 0;
		currentY = 40;
		systemCount = 1;
		printTitle.textContent = title;
		createInitialStructure();
		saveCurrentPage();
	}
	renderPageNav();
	haptic();
}

/* ================= SAVE / LOAD ================= */
saveBtn.onclick = () => {
	saveCurrentPage();
	const data = {
		version: VERSION,
		created: new Date().toISOString(),
		title: printTitle.textContent,
		theme: document.documentElement.getAttribute("data-theme"),
		fontSize: currentFontSize,
		pageCount: pageCount,
		pages: pages
	};
	const json = JSON.stringify(data, null, 2);
	const blob = new Blob([json], { type: "application/json" });
	const url = URL.createObjectURL(blob);
	const a = document.createElement("a");
	a.href = url;
	a.download = `tablature-${Date.now()}.json`;
	a.click();
	URL.revokeObjectURL(url);
	haptic();
};

loadBtn.onclick = () => {
	const input = document.createElement("input");
	input.type = "file";
	input.accept = ".json";
	input.onchange = e => {
		const file = e.target.files[0];
		if (!file) return;
		const reader = new FileReader();
		reader.onload = event => {
			try {
				const data = JSON.parse(event.target.result);
				printTitle.textContent = data.title || "";
				if (data.theme) applyTheme(data.theme);
				if (data.fontSize) {
					currentFontSize = data.fontSize;
					updateFontSizeDisplay();
				}
				pageCount = data.pageCount || 1;
				Object.assign(pages, data.pages);
				currentPage = 0; // force reload
				loadPage(1);
				renderPageNav();
				haptic();
				alert("Tablature charg√©e !");
			} catch (err) {
				alert("Erreur de chargement : fichier invalide");
			}
		};
		reader.readAsText(file);
	};
	input.click();
};

/* ================= UI VISIBILITY ================= */
toggleUI.onclick = () => {
	toolbar.style.display = "none";
	palette.style.display = "none";
	showUIBtn.style.display = "block";
};
showUIBtn.onclick = () => {
	toolbar.style.display = "";
	palette.style.display = "";
	showUIBtn.style.display = "none";
};

/* ================= FONT ================= */
// Tableau nettoy√© : uniquement les polices demand√©es
const fontList = [
	{ name: "Tangerine", value: "'Tangerine', cursive", italic: false },
	{ name: "EB Garamond Italic", value: "'EB Garamond', serif", italic: true },
	{ name: "IM Fell English Italic", value: "'IM Fell English', serif", italic: true }
];

let currentFont = fontList[0]; // Par d√©faut Tangerine

function applyFont(fontObj) {
	currentFont = fontObj;
	// On n'applique PLUS la police au titre (il reste en EB Garamond Normal)
	// On applique uniquement aux symboles de la tablature
	document.querySelectorAll(".symbol").forEach(el => {
		el.style.fontFamily = fontObj.value;
		el.style.fontStyle = fontObj.italic ? "italic" : "normal";
		// Reset fontWeight pour Tangerine qui est naturellement gras
		el.style.fontWeight = (fontObj.name === "Tangerine") ? "700" : "normal";
	});
	localStorage.setItem("tablature_font_index", fontList.indexOf(fontObj));
}

function applyFontSize(size) {
	currentFontSize = size;
	document.querySelectorAll(".symbol").forEach(el => {
		el.style.fontSize = size + "px";
	});
	localStorage.setItem("tablature_font_size", size);
	updateFontSizeDisplay();
}

function updateFontSizeDisplay() {
	const display = document.getElementById("fontSizeDisplay");
	if (display) display.textContent = currentFontSize + "px";
}

/* ================= UNDO ================= */
function serializeState() {
	return JSON.stringify({
		title: printTitle.textContent,
		theme: document.documentElement.getAttribute("data-theme"),
		fontSize: currentFontSize,
		fontIndex: fontList.indexOf(currentFont),
		systemCount: systemCount,
		elements: [...canvas.children].map(el => {
			if (el.classList.contains("draw")) {
				return {
					class: "draw", left: el.style.left, top: el.style.top,
					d: el.querySelector("path").getAttribute("d")
				};
			}
			return {
				class: el.className,
				text: el.textContent || "",
				left: el.style.left,
				top: el.style.top,
				height: el.style.height || "",
				fontSize: el.style.fontSize || ""
			};
		})
	});
}

function pushUndo() {
	undoStack.push(serializeState());
	if (undoStack.length > MAX_UNDO) undoStack.shift();
}

undoBtn.onclick = () => {
	if (!undoStack.length) return;
	restoreState(undoStack.pop(), false);
	haptic();
};

/* ================= PERSISTENCE ================= */
function saveState() {
	localStorage.setItem("tablature_state", serializeState());
}

function restoreState(raw, save = true) {
	const s = typeof raw === "string" ? JSON.parse(raw) : raw;
	canvas.innerHTML = "";
	lines.length = 0;
	currentY = 40;
	systemCount = s.systemCount || 1;
	printTitle.textContent = s.title || "Titre du Morceau";

	if (s.theme) applyTheme(s.theme);
	if (s.fontSize) {
		currentFontSize = s.fontSize;
		updateFontSizeDisplay();
	}
	if (s.fontIndex !== undefined && fontList[s.fontIndex]) {
		currentFont = fontList[s.fontIndex];
		// Mise √† jour du selecteur
		document.querySelector("select").selectedIndex = s.fontIndex;
	}

	s.elements.forEach(e => {
		if (e.class === "draw") {
			const w = document.createElement("div");
			w.className = "draw";
			w.style.left = e.left; w.style.top = e.top;
			const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
			svg.setAttribute("width", DRAW_W); svg.setAttribute("height", DRAW_H);
			const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
			p.setAttribute("d", e.d);
			svg.appendChild(p);
			w.appendChild(svg);
			canvas.appendChild(w);
			makeDraggable(w);
			return;
		}

		const el = document.createElement("div");
		el.className = e.class;
		el.textContent = e.text;
		el.style.left = e.left;
		el.style.top = e.top;
		if (e.height) el.style.height = e.height;
		
		// Restaurer la police courante
		if (el.classList.contains("symbol")) {
			el.style.fontSize = e.fontSize || (currentFontSize + "px");
			el.style.fontFamily = currentFont.value;
			el.style.fontStyle = currentFont.italic ? "italic" : "normal";
			el.style.fontWeight = (currentFont.name === "Tangerine") ? "700" : "normal";
			makeDraggable(el);
		}
		
		canvas.appendChild(el);

		if (el.classList.contains("line")) {
			lines.push(parseFloat(e.top));
			currentY = parseFloat(e.top) + LINE_SPACING;
		}
		if (el.classList.contains("bar")) makeDraggable(el);
	});
	
	if (showVerticalGuides) renderVerticalGuides();
	if (save) saveState();
}

function restoreFromStorage() {
	const raw = localStorage.getItem("tablature_state");
	if (raw) restoreState(raw, false);
	else { createInitialStructure(); saveState(); }
	
	const savedFontIdx = localStorage.getItem("tablature_font_index");
	if (savedFontIdx) {
		const idx = parseInt(savedFontIdx);
		if (fontList[idx]) applyFont(fontList[idx]);
	}
}

/* ================= TITLE ================= */
editTitle.onclick = () => {
	const t = prompt("Titre du morceau :", printTitle.textContent || "");
	if (t === null) return;
	pushUndo();
	printTitle.textContent = t.trim();
	saveState();
	haptic();
};

/* ================= TOOLS ================= */
function setTool(t) {
	tool = t;
	toolPlace.classList.toggle("active", t === "place");
	toolSelect.classList.toggle("active", t === "select");
}

toolPlace.onclick = () => {
	if (tool === "place") { tool = null; toolPlace.classList.remove("active"); }
	else setTool("place");
	haptic();
};

toolSelect.onclick = () => {
	setTool("select");
	if (selectedElement) {
		selectedElement.classList.remove("selected");
		selectedElement = null;
	}
	haptic();
};

toggleSnap.onclick = () => {
	snap = !snap;
	toggleSnap.classList.toggle("active", snap);
	haptic();
};

toggleVGuides.onclick = () => {
	showVerticalGuides = !showVerticalGuides;
	toggleVGuides.classList.toggle("active", showVerticalGuides);
	renderVerticalGuides();
	haptic();
};

/* ================= STRUCTURE ================= */
function addLine(type) {
	const l = document.createElement("div");
	l.className = "line " + type;
	l.style.top = currentY + "px";
	canvas.appendChild(l);
	lines.push(currentY);
	currentY += LINE_SPACING;
	if (currentY + 100 > canvas.offsetHeight) canvas.style.minHeight = (currentY + 200) + "px";
}

function addSystemSideBars(startY, systemNum) {
	const leftBar = document.createElement("div");
	leftBar.className = "bar system-bar left";
	leftBar.style.top = startY + "px";
	leftBar.style.height = (5 * LINE_SPACING) + "px";

	const rightBar = document.createElement("div");
	rightBar.className = "bar system-bar right";
	rightBar.style.top = startY + "px";
	rightBar.style.height = (5 * LINE_SPACING) + "px";

	const numLabel = document.createElement("div");
	numLabel.className = "system-number";
	numLabel.textContent = systemNum;
	numLabel.style.top = startY + "px";

	canvas.appendChild(leftBar);
	canvas.appendChild(rightBar);
	canvas.appendChild(numLabel);
}

function createInitialStructure() {
	addLine("white"); addLine("white");
	const systemTop = currentY;
	for (let i = 0; i < 6; i++) addLine("black");
	addSystemSideBars(systemTop, 1);
	systemCount = 1;
}

addSystemBtn.onclick = () => {
	if (systemCount >= MAX_SYSTEMS) { alert(`Max ${MAX_SYSTEMS} port√©es`); return; }
	pushUndo();
	addLine("white"); addLine("white");
	const systemTop = currentY;
	for (let i = 0; i < 6; i++) addLine("black");
	systemCount++;
	addSystemSideBars(systemTop, systemCount);
	if (systemCount === MAX_SYSTEMS) addLine("white");
	saveState();
	haptic();
};

/* ================= SNAP ================= */
function nearestLine(y) {
	return lines.reduce((a, b) => Math.abs(b - y) < Math.abs(a - y) ? b : a);
}
function snapY(y) { return (snap && lines.length) ? nearestLine(y) : y; }

function snapToNearbySymbols(x, y) {
	if (!snap) return x;
	const symbols = document.querySelectorAll(".symbol");
	let nearestX = null;
	let minDist = SNAP_THRESHOLD;
	symbols.forEach(sym => {
		const symY = parseFloat(sym.style.top);
		// Petite tol√©rance verticale pour trouver les voisins
		if (Math.abs(symY - y) < LINE_SPACING * 3) {
			const symX = parseFloat(sym.style.left);
			const dist = Math.abs(symX - x);
			if (dist < minDist) {
				minDist = dist;
				nearestX = symX;
			}
		}
	});
	return nearestX !== null ? nearestX : x;
}

function firstLineOfSystem(y) {
	const lineY = nearestLine(y);
	let idx = lines.indexOf(lineY);
	let count = 0;
	while (idx > 0 && count < 5) {
		const prevY = lines[idx - 1];
		if (!document.querySelector(`.line.black[style*="top: ${prevY}px"]`)) break;
		idx--;
		count++;
	}
	return lines[idx];
}

function renderVerticalGuides() {
	document.querySelectorAll(".vertical-guide").forEach(g => g.remove());
	if (!showVerticalGuides) return;
	const step = 60;
	const width = canvas.offsetWidth;
	for (let x = step; x < width; x += step) {
		const g = document.createElement("div");
		g.className = "vertical-guide";
		g.style.left = x + "px";
		canvas.appendChild(g);
	}
}

/* ================= INTERACTION ================= */
function getCanvasCoords(touch) {
	const canvasRect = canvas.getBoundingClientRect();
	return {
		x: touch.clientX - canvasRect.left,
		y: touch.clientY - canvasRect.top
	};
}

/* ===== OFFSET TYPO CIBL√â ===== */
const LETTER_VERTICAL_OFFSET = {
	a: 2,
	c: 2,
	e: 2,
	n: 2,
	m: 2
};

/* ===== CORRECTION HORIZONTALE DES /a ===== */
const SLASH_X_OFFSET = {
	"/a": -6,
	"//a": -10,
	"///a": -14
};

/* ===== JITTER MANUSCRIT (POSE UNIQUEMENT) ===== */
function applyJitter(el) {
	const sizeJitter = (Math.random() * 0.8 - 0.4); // ¬±0.4px
	const rotJitter  = (Math.random() * 0.6 - 0.3); // ¬±0.3¬∞

	// Taille l√©g√®rement variable
	el.style.fontSize = (currentFontSize + sizeJitter) + "px";

	// Rotation tr√®s l√©g√®re
	el.style.transform += ` rotate(${rotJitter}deg)`;

	// Marqueur (s√©curit√© : ne jamais rejitter)
	el.dataset.jittered = "1";
}

function symbolVerticalOffset(char) {
	let base = currentFontSize * 0.55;

	if (LETTER_VERTICAL_OFFSET[char]) {
		base += LETTER_VERTICAL_OFFSET[char];
	}

	return base;
}

canvas.addEventListener("touchstart", e => {
	if (tool === "select" && !e.target.closest(".symbol, .bar, .draw")) {
		if (selectedElement) {
			selectedElement.classList.remove("selected");
			selectedElement = null;
		}
	}

	const { x, y } = getCanvasCoords(e.touches[0]);
	pushUndo();

	/* ===== MODE DESSIN ===== */
	if (selected === "__draw__") {
		drawing = true;
		drawStart = { x, y };

		const w = document.createElement("div");
		w.className = "draw";
		w.style.left = (x - DRAW_W / 2) + "px";
		w.style.top  = (y - DRAW_H / 2) + "px";

		const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
		svg.setAttribute("width", DRAW_W);
		svg.setAttribute("height", DRAW_H);

		const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
		p.setAttribute("d", `M ${DRAW_W / 2} ${DRAW_H / 2}`);

		svg.appendChild(p);
		w.appendChild(svg);
		canvas.appendChild(w);

		currentPath = p;
		selectedElement = w;
		return;
	}

	/* ===== MODE BARRE ===== */
	if (placingBar) {
		placingBar = false;
		addBar.classList.remove("placing");

		const topLine = firstLineOfSystem(y);
		const b = document.createElement("div");
		b.className = "bar";
		b.style.left = x + "px";
		b.style.top  = topLine + "px";
		b.style.height = (5 * LINE_SPACING) + "px";

		canvas.appendChild(b);
		makeDraggable(b);
		saveState();
		haptic();
		return;
	}

	/* ===== POSE DE SYMBOLE ===== */
	if (tool === "place" && selected !== "__draw__") {
		const snappedY = snapY(y);
		const snappedX = snapToNearbySymbols(x, snappedY);

		const s = document.createElement("div");
		s.className = "symbol";
		s.textContent = selected;

		s.style.fontSize = currentFontSize + "px";
		s.style.fontFamily = currentFont.value;
		s.style.fontStyle = currentFont.italic ? "italic" : "normal";
		s.style.fontWeight = (currentFont.name === "Tangerine") ? "700" : "normal";

		// OFFSET VERTICAL PAR GLYPHE
		const offset = symbolVerticalOffset(s.textContent);
		s.style.left = snappedX + "px";
		s.style.top  = (snappedY - offset) + "px";

		// OFFSET HORIZONTAL POUR /a //a ///a
		if (SLASH_X_OFFSET[s.textContent]) {
			s.style.transform =
				`translateX(calc(-50% + ${SLASH_X_OFFSET[s.textContent]}px))`;
		} else {
			s.style.transform = "translateX(-50%)";
		}

		// JITTER MANUSCRIT (UNE SEULE FOIS, √Ä LA POSE)
		applyJitter(s);

		canvas.appendChild(s);
		makeDraggable(s);

		s.classList.add("flash");
		setTimeout(() => s.classList.remove("flash"), 300);

		saveState();
		haptic();
	}
}, { passive: false });

canvas.addEventListener("touchmove", e => {
	if (!drawing) return;
	e.preventDefault();

	const { x, y } = getCanvasCoords(e.touches[0]);
	const dx = x - drawStart.x + DRAW_W / 2;
	const dy = y - drawStart.y + DRAW_H / 2;

	currentPath.setAttribute(
		"d",
		currentPath.getAttribute("d") + ` L ${dx} ${dy}`
	);
}, { passive: false });

canvas.addEventListener("touchend", () => {
	if (!drawing) return;

	drawing = false;
	currentPath = null;

	if (selectedElement) {
		makeDraggable(selectedElement);
		selectedElement = null;
	}

	selected = "a";
	tool = null;
	toolPlace.classList.remove("active");

	document
		.querySelectorAll(".palette-item")
		.forEach(item => item.classList.remove("active"));

	saveState();
});

/* ================= DRAG ================= */
function makeDraggable(el) {
	el.addEventListener("touchstart", async e => {
		if (tool !== "select") return;
		e.preventDefault();
		pushUndo();
		if (selectedElement && selectedElement !== el) selectedElement.classList.remove("selected");
		selectedElement = el;
		el.classList.add("selected");
		active = el;
		haptic();

		if (!dragLoupe) {
			dragLoupe = document.createElement("div");
			dragLoupe.className = "drag-loupe";
			loupeCanvas = document.createElement("canvas");
			loupeCanvas.width = 120; loupeCanvas.height = 120;
			loupeCtx = loupeCanvas.getContext("2d");
			dragLoupe.appendChild(loupeCanvas);
			document.body.appendChild(dragLoupe);
			const cross = document.createElement("div");
			cross.className = "loupe-cross";
			dragLoupe.appendChild(cross);
			
			// Capture propre pour la loupe
			const snap = await html2canvas(canvas, {
				backgroundColor: getComputedStyle(canvas).backgroundColor,
				scale: 2,
				logging: false
			});
			loupeImage = snap;
		}
	}, { passive: false });

	el.addEventListener("touchmove", e => {
		if (!active || !loupeImage) return;
		e.preventDefault();
		const t = e.touches[0];
		const { x, y } = getCanvasCoords(t);
		const snappedY = snapY(y);
		const snappedX = el.classList.contains("symbol") ? snapToNearbySymbols(x, snappedY) : x;

		if (active.classList.contains("symbol")) {
			const offset = symbolVerticalOffset();
			active.style.left = snappedX + "px";
			active.style.top  = (snappedY - offset) + "px";
		} else {
			active.style.left = snappedX + "px";
			active.style.top  = snappedY + "px";
		}

		dragLoupe.style.left = t.clientX + "px";
		dragLoupe.style.top  = t.clientY + "px";

		loupeCtx.clearRect(0, 0, 120, 120);
		loupeCtx.drawImage(loupeImage, (x * 2) - 50, (y * 2) - 50, 100, 100, 0, 0, 120, 120);
	}, { passive: false });

	el.addEventListener("touchend", () => {
		if (dragLoupe) { dragLoupe.remove(); dragLoupe = null; }
		active = null;
		saveState();
	});
}

/* ================= DELETE / CLEAR ================= */
deleteBtn.onclick = () => {
	setTool("select");
	if (!selectedElement) return;
	pushUndo();
	selectedElement.remove();
	selectedElement = null;
	saveState();
	haptic();
};

clearAllBtn.onclick = () => {
	if (!confirm("Effacer toute la tablature ?")) return;
	pushUndo();
	canvas.innerHTML = "";
	lines.length = 0;
	currentY = 40;
	systemCount = 1;
	createInitialStructure();
	saveState();
	haptic();
};

addBar.onclick = () => {
	placingBar = true;
	addBar.classList.add("placing");
	setTool("place");
	haptic();
};

/* ================= PALETTE ================= */
[
	"a","b","c","d","e","f","g","h","j","k",
	"l","m","n",
	"/a","//a","///a","4","5","6",
	",",".","‚åí","‚å£","|","‚úé"
].forEach(s => {
	const p = document.createElement("div");
	p.className = "palette-item";
	p.textContent = s;

	// Plus de condition sp√©ciale pour 'f' (il est trait√© normalement)

	p.onclick = () => {
		document.querySelectorAll(".palette-item").forEach(item => item.classList.remove("active"));
		p.classList.add("active");
		selected = (s === "‚úé") ? "__draw__" : s;
		setTool("place");
		haptic();
	};
	palette.appendChild(p);
});

const customInput = document.createElement("input");
customInput.id = "customChar";
customInput.placeholder = "‚ú±";
customInput.maxLength = 3;
customInput.oninput = () => {
	if (customInput.value.trim() !== "") {
		selected = customInput.value.trim();
		setTool("place");
	}
};
palette.appendChild(customInput);

/* ===== FONT SELECTOR ===== */
const fontSelect = document.createElement("select");
fontSelect.style.fontSize = "14px";
fontSelect.style.marginLeft = "6px";

fontList.forEach((f, index) => {
	const opt = document.createElement("option");
	opt.textContent = f.name;
	opt.value = index;
	fontSelect.appendChild(opt);
});

fontSelect.onchange = () => {
	const selectedFont = fontList[fontSelect.value];
	applyFont(selectedFont);
	saveState();
	haptic();
};
palette.appendChild(fontSelect);

/* ===== FONT SIZE CONTROLS ===== */
const fontSizeControls = document.createElement("div");
fontSizeControls.className = "font-size-controls";
const decreaseBtn = document.createElement("button");
decreaseBtn.className = "font-size-btn";
decreaseBtn.textContent = "-";
decreaseBtn.onclick = () => { if (currentFontSize > 12) { applyFontSize(currentFontSize - 2); saveState(); haptic(); } };
const fontSizeDisplay = document.createElement("div");
fontSizeDisplay.id = "fontSizeDisplay";
fontSizeDisplay.textContent = currentFontSize + "px";
const increaseBtn = document.createElement("button");
increaseBtn.className = "font-size-btn";
increaseBtn.textContent = "+";
increaseBtn.onclick = () => { if (currentFontSize < 50) { applyFontSize(currentFontSize + 2); saveState(); haptic(); } };

fontSizeControls.appendChild(decreaseBtn);
fontSizeControls.appendChild(fontSizeDisplay);
fontSizeControls.appendChild(increaseBtn);
palette.appendChild(fontSizeControls);

/* ================= EXPORT PDF ================= */
document.getElementById("exportPDF").onclick = () => document.getElementById("exportModal").classList.add("active");

async function confirmExport() {
	const showNumbers = document.getElementById("showSystemNumbers").checked;
	if (!showNumbers) document.querySelectorAll(".system-number").forEach(n => n.style.display = "none");
	closeModal("exportModal");
	saveCurrentPage();
	const originalPage = currentPage;
	const ui = [toolbar, palette];
	ui.forEach(el => el.style.display = "none");
	await new Promise(r => requestAnimationFrame(r));

	const pdf = new jspdf.jsPDF("p", "mm", "a4");
	const pageWidth = 210;
	const y = 15;

	const capture = async (pageNum, addPage) => {
		if (!pages[pageNum]) return;
		loadPage(pageNum);
		await new Promise(r => setTimeout(r, 150));
		const exportWrapper = document.createElement("div");
		exportWrapper.style.background = getComputedStyle(document.body).backgroundColor;
		exportWrapper.style.padding = "20px 24px";
		const titleClone = printTitle.cloneNode(true);
		titleClone.style.marginBottom = "16px";
		exportWrapper.appendChild(titleClone);
		const canvasClone = canvas.cloneNode(true);
		exportWrapper.appendChild(canvasClone);
		document.body.appendChild(exportWrapper);

		const canvasImg = await html2canvas(exportWrapper, {
			scale: 4,
			backgroundColor: getComputedStyle(document.body).backgroundColor,
			useCORS: true,
			logging: false,
			removeContainer: true
		});
		exportWrapper.remove();
		const imgWidth = pageWidth;
		const imgHeight = canvasImg.height * imgWidth / canvasImg.width;
		if (addPage) pdf.addPage();
		pdf.addImage(canvasImg.toDataURL("image/png"), "PNG", 0, y, imgWidth, imgHeight);
	};

	for (let i = 1; i <= pageCount; i++) await capture(i, i > 1);
	loadPage(originalPage);
	ui.forEach(el => el.style.display = "");
	if (!showNumbers) document.querySelectorAll(".system-number").forEach(n => n.style.display = "");
	pdf.save("tablature-barok.pdf");
	haptic();
}

/* ================= UI DRAG VERTICAL ================= */
function makeUIDraggableVertical(el, handleEl, storageKey) {
	let startY = 0, startTop = 0, dragging = false;
	handleEl.addEventListener("touchstart", e => {
		startY = e.touches[0].clientY;
		startTop = el.getBoundingClientRect().top;
		dragging = true; el.style.transition = "none"; e.stopPropagation();
	}, { passive: false });
	document.addEventListener("touchmove", e => {
		if (!dragging) return;
		e.preventDefault();
		let newTop = startTop + (e.touches[0].clientY - startY);
		newTop = Math.max(8, Math.min(window.innerHeight - el.offsetHeight - 8, newTop));
		el.style.top = newTop + "px"; el.style.bottom = "auto";
	}, { passive: false });
	document.addEventListener("touchend", () => {
		if (dragging) { localStorage.setItem(storageKey, el.style.top); el.style.transition = ""; dragging = false; }
	});
}
function restoreUIVerticalPosition(el, storageKey, defaultTop) {
	const saved = localStorage.getItem(storageKey);
	if (saved) { el.style.top = saved; el.style.bottom = "auto"; }
	else if (defaultTop) { el.style.top = defaultTop; el.style.bottom = "auto"; }
}

/* ================= INIT ================= */
restoreFromStorage();
renderPageNav();
restoreUIVerticalPosition(toolbar, "toolbarY", "8px");
restoreUIVerticalPosition(palette, "paletteY", null);
makeUIDraggableVertical(toolbar, document.getElementById("toolbarHandle"), "toolbarY");
makeUIDraggableVertical(palette, document.getElementById("paletteHandle"), "paletteY");
pushUndo();
</script>
</body>
</html>
